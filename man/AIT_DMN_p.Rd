% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AIT_DMN_p.R
\name{AIT_DMN_p}
\alias{AIT_DMN_p}
\title{An adaptive independence test for Dirichlet-multinomial modeled microbiome data}
\usage{
AIT_DMN_p(x, y, lambda, permutation = 1000, slice = FALSE)
}
\arguments{
\item{x}{a vector of bacterial counts follows dirichlet-multinomial distribution.}

\item{y}{a continuous or categorical outcome vector.}

\item{lambda}{the panalty for the number of slices.}

\item{permutation}{permutation time for the test (default 1000). It is recommended to permutate
100 times to reduce the amount of calculation while \code{y} is a continuous variable.}

\item{slice}{a bool variable to determine whether return slicing scheme (default FALSE).}
}
\value{
results of the test: \code{statistics} and \code{p_value} (if \code{slice=TRUE}, also return \code{slicing}).
}
\description{
An adaptive independence test based on the Dirichlet-multinomial distribution. It tests
the independence between a vector of bacterial counts and a continuous variable or a
categorical variable with many levels.
}
\examples{

##################################### a simulated example ###################################
library(GUniFrac)
set.seed(2019)
data(x.d)
y=sort(rep(1:10,10))/2
y.d=y
lambda_d=lambda_selection("DMN",x.d,y.d,100)
AIT_DMN_p(x.d,y.d,lambda_d,1000,slice = TRUE)

set.seed(2019)
y.d=sort(runif(100, min=0.01, max=1))
#lambda_d=lambda_selection("DMN",x.d,y.d,100)  #3.125
lambda_d=3.125
AIT_DMN_p(x.d,y.d,lambda_d,100,slice = TRUE)

####################################### a real example #####################################

set.seed(2019)
data(individual_index)
data(taxa_family)
index.tmp=subset(individual_index,individual_index$Age<=40&individual_index$Country=="Malawi")
age=index.tmp$Age
taxa_age=taxa_family[row.names(index.tmp),]
taxa_age_sub <- taxa_age[,(colSums(taxa_age != 0) ) >nrow(taxa_age)*0.25]
taxa_age_sub=taxa_age_sub[,apply(taxa_age_sub, 2, function(x){max(x)})>sum(taxa_age_sub)*0.0002]
dim(taxa_age_sub)
x=Rarefy(taxa_age_sub,depth=10000)$otu.tab.rff   #rarefy to the same sequencing depth
x=x[,colSums(x)>0]
age.group=c(0,0.25,0.5,0.75,1,1.5,2,2.5,3)
y=age
for(i in 1:length(age)){
 if(age[i]>3){
   y[i]=ceiling(age[i])}
 for(j in 1:(length(age.group)-1)){
   if(age.group[j]<age[i] &age[i] <=age.group[j+1]){
     y[i]=age.group[j+1]
   }
 }
}

theta_calculate(x)  # here theta>0.1, thus we use function AIT_DMN_p
lambda_d=lambda_selection(method="DMN",x,y,100)  #
test.results=AIT_DMN_p(x,y,lambda_d,1000,slice=TRUE)
print(test.results)

}
\seealso{
\code{\link{x.d}},\code{\link{individual_index}},\code{\link{taxa_family}}
}
